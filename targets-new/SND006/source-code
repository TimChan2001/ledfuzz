in flac.c:

165 static sf_count_t
166 flac_buffer_copy (SF_PRIVATE *psf)
167 {   FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
168     const FLAC__Frame *frame = pflac->frame ;
169     const int32_t* const *buffer = pflac->wbuffer ;
170     unsigned i = 0, j, offset, channels, len ;
171 
172     /*
173     **      frame->header.blocksize is variable and we're using a constant blocksize
174     **      of FLAC__MAX_BLOCK_SIZE.
175     **      Check our assumptions here.
176     */
177     if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)
178     {       psf_log_printf (psf, "Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;
179             psf->error = SFE_INTERNAL ;
180             return 0 ;
181             } ;
182 
183     if (frame->header.channels > FLAC__MAX_CHANNELS)
184             psf_log_printf (psf, "Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;
185 
186     channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;
187 
188     if (pflac->ptr == NULL)
189     {       /*
190             ** This pointer is reset to NULL each time the current frame has been
191             ** decoded. Somehow its used during encoding and decoding.
192             */
193             for (i = 0 ; i < channels ; i++)
194             {
195                     if (pflac->rbuffer [i] == NULL)
196                             pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;
197 
198                     memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;
199                     } ;
200             pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;
201 
202             return 0 ;
203             } ;
204 
205     len = SF_MIN (pflac->len, frame->header.blocksize) ;
206 
207     if (pflac->remain % channels != 0)
208     {       psf_log_printf (psf, "Error: pflac->remain %u    channels %u\n", pflac->remain, channels) ;
209             return 0 ;
210             } ;
211 
212     switch (pflac->pcmtype)
213     {       case PFLAC_PCM_SHORT :
214                     {       short *retpcm = (short*) pflac->ptr ;
215                             int shift = 16 - frame->header.bits_per_sample ;
216                             if (shift < 0)
217                             {       shift = abs (shift) ;
218                                     for (i = 0 ; i < len && pflac->remain > 0 ; i++)
219                                     {       offset = pflac->pos + i * channels ;
220 
221                                             if (pflac->bufferpos >= frame->header.blocksize)
222                                                     break ;
223 
224                                             if (offset + channels > pflac->len)
225                                                     break ;
226 
227                                             for (j = 0 ; j < channels ; j++)
228                                                     retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;
229                                             pflac->remain -= channels ;
230                                             pflac->bufferpos ++ ;
231                                             }
232                                     }
233                             else
234                             {       for (i = 0 ; i < len && pflac->remain > 0 ; i++)
235                                     {       offset = pflac->pos + i * channels ;
236 
237                                             if (pflac->bufferpos >= frame->header.blocksize)
238                                                     break ;
239 
240                                             if (offset + channels > pflac->len)
241                                                     break ;
242 
243                                             for (j = 0 ; j < channels ; j++)
244                                                     retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;
245 
246                                             pflac->remain -= channels ;
247                                             pflac->bufferpos ++ ;
248                                             } ;
249                                     } ;
250                             } ;
251                     break ;
252 
253             case PFLAC_PCM_INT :
254                     {       int *retpcm = (int*) pflac->ptr ;
255                             int shift = 32 - frame->header.bits_per_sample ;
256                             for (i = 0 ; i < len && pflac->remain > 0 ; i++)
257                             {       offset = pflac->pos + i * channels ;
258 
259                                     if (pflac->bufferpos >= frame->header.blocksize)
260                                             break ;
261 
262                                     if (offset + channels > pflac->len)
263                                             break ;
264 
265                                     for (j = 0 ; j < channels ; j++)
266                                             retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;
267                                     pflac->remain -= channels ;
268                                     pflac->bufferpos++ ;
269                                     } ;
270                             } ;
271                     break ;
272 
273             case PFLAC_PCM_FLOAT :
274                     {       float *retpcm = (float*) pflac->ptr ;
275                             float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
276 
277                             for (i = 0 ; i < len && pflac->remain > 0 ; i++)
278                             {       offset = pflac->pos + i * channels ;
279 
280                                     if (pflac->bufferpos >= frame->header.blocksize)
281                                             break ;
282 
283                                     if (offset + channels > pflac->len)
284                                             break ;
285 
286                                     for (j = 0 ; j < channels ; j++)
287                                             retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
288                                     pflac->remain -= channels ;
289                                     pflac->bufferpos++ ;
290                                     } ;
291                             } ;
292                     break ;
293 
294             case PFLAC_PCM_DOUBLE :
295                     {       double *retpcm = (double*) pflac->ptr ;
296                             double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
297 
298                             for (i = 0 ; i < len && pflac->remain > 0 ; i++)
299                             {       offset = pflac->pos + i * channels ;
300 
301                                     if (pflac->bufferpos >= frame->header.blocksize)
302                                             break ;
303 
304                                     if (offset + channels > pflac->len)
305                                             break ;
306 
307                                     for (j = 0 ; j < channels ; j++)
308                                             retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
309                                     pflac->remain -= channels ;
310                                     pflac->bufferpos++ ;
311                                     } ;
312                             } ;
313                     break ;
314 
315             default :
316                     return 0 ;
317             } ;
318 
319     offset = i * channels ;
320     pflac->pos += i * channels ;
321 
322     return offset ;
323 } /* flac_buffer_copy */