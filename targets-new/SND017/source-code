in wavlike.c:

123 int
124 wavlike_read_fmt_chunk (SF_PRIVATE *psf, int fmtsize)
125 {   WAVLIKE_PRIVATE * wpriv ;
126     WAV_FMT *wav_fmt ;
127     int     bytesread, k, bytespersec = 0 ;
128 
129     if ((wpriv = psf->container_data) == NULL)
130             return SFE_INTERNAL ;
131     wav_fmt = &wpriv->wav_fmt ;
132 
133     memset (wav_fmt, 0, sizeof (WAV_FMT)) ;
134 
135     if (fmtsize < 16)
136             return SFE_WAV_FMT_SHORT ;
137 
138     /* assume psf->rwf_endian is already properly set */
139 
140     /* Read the minimal WAV file header here. */
141     bytesread = psf_binheader_readf (psf, "224422",
142                                     &(wav_fmt->format), &(wav_fmt->min.channels),
143                                     &(wav_fmt->min.samplerate), &(wav_fmt->min.bytespersec),
144                                     &(wav_fmt->min.blockalign), &(wav_fmt->min.bitwidth)) ;
145 
146     psf_log_printf (psf, "  Format        : 0x%X => %s\n", wav_fmt->format, wavlike_format_str (wav_fmt->format)) ;
147     psf_log_printf (psf, "  Channels      : %d\n", wav_fmt->min.channels) ;
148     psf_log_printf (psf, "  Sample Rate   : %d\n", wav_fmt->min.samplerate) ;
149 
150     if (wav_fmt->format == WAVE_FORMAT_PCM && wav_fmt->min.blockalign == 0
151             && wav_fmt->min.bitwidth > 0 && wav_fmt->min.channels > 0)
152     {       wav_fmt->min.blockalign = wav_fmt->min.bitwidth / 8 + (wav_fmt->min.bitwidth % 8 > 0 ? 1 : 0) ;
153             wav_fmt->min.blockalign *= wav_fmt->min.channels ;
154             psf_log_printf (psf, "  Block Align   : 0 (should be %d)\n", wav_fmt->min.blockalign) ;
155             }
156     else
157             psf_log_printf (psf, "  Block Align   : %d\n", wav_fmt->min.blockalign) ;
158 
159     if (wav_fmt->format == WAVE_FORMAT_PCM && wav_fmt->min.bitwidth == 24 &&
160                     wav_fmt->min.blockalign == 4 * wav_fmt->min.channels)
161     {       psf_log_printf (psf, "  Bit Width     : 24\n") ;
162 
163             psf_log_printf (psf, "\n"
164                     "  Ambiguous information in 'fmt ' chunk. Possibile file types:\n"
165                     "    0) Invalid IEEE float file generated by Syntrillium's Cooledit!\n"
166                     "    1) File generated by ALSA's arecord containing 24 bit samples in 32 bit containers.\n"
167                     "    2) 24 bit file with incorrect Block Align value.\n"
168                     "\n") ;
169 
170             wpriv->fmt_is_broken = 1 ;
171             }
172     else if (wav_fmt->min.bitwidth == 0)
173     {       switch (wav_fmt->format)
174             {       case WAVE_FORMAT_GSM610 :
175                     case WAVE_FORMAT_IPP_ITU_G_723_1 :
176                                     psf_log_printf (psf, "  Bit Width     : %d\n", wav_fmt->min.bitwidth) ;
177                                     break ;
178                     default :
179                                     psf_log_printf (psf, "  Bit Width     : %d (should not be 0)\n", wav_fmt->min.bitwidth) ;
180                     }
181             }
182     else
183     {       switch (wav_fmt->format)
184             {       case WAVE_FORMAT_GSM610 :
185                     case WAVE_FORMAT_IPP_ITU_G_723_1 :
186             psf_log_printf (psf, "  Bit Width     : %d (should be 0)\n", wav_fmt->min.bitwidth) ;
187                                     break ;
188                     default :
189                                     psf_log_printf (psf, "  Bit Width     : %d\n", wav_fmt->min.bitwidth) ;
190                     }
191             } ;
192 
193     psf->sf.samplerate      = wav_fmt->min.samplerate ;
194     psf->sf.frames          = 0 ;                                   /* Correct this when reading data chunk. */
195     psf->sf.channels        = wav_fmt->min.channels ;
196 
197     switch (wav_fmt->format)
198     {       case WAVE_FORMAT_PCM :
199             case WAVE_FORMAT_IEEE_FLOAT :
200                             bytespersec = wav_fmt->min.samplerate * wav_fmt->min.blockalign ;
201                             if (wav_fmt->min.bytespersec != (unsigned) bytespersec)
202                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec, bytespersec) ;
203                             else
204                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec) ;
205 
206                             psf->bytewidth = BITWIDTH2BYTES (wav_fmt->min.bitwidth) ;
207                             break ;
208 
209             case WAVE_FORMAT_ALAW :
210             case WAVE_FORMAT_MULAW :
211                             if (wav_fmt->min.bytespersec != wav_fmt->min.samplerate * wav_fmt->min.blockalign)
212                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec, wav_fmt->min.samplerate * wav_fmt->min.blockalign) ;
213                             else
214                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec) ;
215 
216                             psf->bytewidth = 1 ;
217                             if (fmtsize >= 18)
218                             {       bytesread += psf_binheader_readf (psf, "2", &(wav_fmt->size20.extrabytes)) ;
219                                     psf_log_printf (psf, "  Extra Bytes   : %d\n", wav_fmt->size20.extrabytes) ;
220                                     } ;
221                             break ;
222 
223             case WAVE_FORMAT_IMA_ADPCM :
224                             if (wav_fmt->min.bitwidth != 4)
225                                     return SFE_WAV_ADPCM_NOT4BIT ;
226                             if (wav_fmt->min.channels < 1 || wav_fmt->min.channels > 2)
227                                     return SFE_WAV_ADPCM_CHANNELS ;
228 
229                             bytesread += psf_binheader_readf (psf, "22", &(wav_fmt->ima.extrabytes), &(wav_fmt->ima.samplesperblock)) ;
230                             psf_log_printf (psf, "  Extra Bytes   : %d\n", wav_fmt->ima.extrabytes) ;
231                             if (wav_fmt->ima.samplesperblock < 1)
232                             {       psf_log_printf (psf, "  Samples/Block : %d (should be > 0)\n", wav_fmt->ima.samplesperblock) ;
233                                     return SFE_WAV_ADPCM_SAMPLES ;
234                                     }
235                             else
236                                     psf_log_printf (psf, "  Samples/Block : %d\n", wav_fmt->ima.samplesperblock) ;
237 
238                             bytespersec = (wav_fmt->ima.samplerate * wav_fmt->ima.blockalign) / wav_fmt->ima.samplesperblock ;
239                             if (wav_fmt->ima.bytespersec != (unsigned) bytespersec)
240                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ima.bytespersec, bytespersec) ;
241                             else
242                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->ima.bytespersec) ;
243 
244                             break ;
245 
246             case WAVE_FORMAT_MS_ADPCM :
247                             if (wav_fmt->msadpcm.bitwidth != 4)
248                                     return SFE_WAV_ADPCM_NOT4BIT ;
249                             if (wav_fmt->msadpcm.channels < 1 || wav_fmt->msadpcm.channels > 2)
250                                     return SFE_WAV_ADPCM_CHANNELS ;
251 
252                             bytesread += psf_binheader_readf (psf, "222", &(wav_fmt->msadpcm.extrabytes),
253                                                             &(wav_fmt->msadpcm.samplesperblock), &(wav_fmt->msadpcm.numcoeffs)) ;
254 
255                             psf_log_printf (psf, "  Extra Bytes   : %d\n", wav_fmt->msadpcm.extrabytes) ;
256                             if (wav_fmt->ima.samplesperblock < 1)
257                             {       psf_log_printf (psf, "  Samples/Block : %d (should be > 0)\n", wav_fmt->ima.samplesperblock) ;
258                                     return SFE_WAV_ADPCM_SAMPLES ;
259                                     }
260                             else
261                                     psf_log_printf (psf, "  Samples/Block : %d\n", wav_fmt->ima.samplesperblock) ;
262 
263                             bytespersec = (wav_fmt->min.samplerate * wav_fmt->min.blockalign) / wav_fmt->msadpcm.samplesperblock ;
264                             if (wav_fmt->min.bytespersec == (unsigned) bytespersec)
265                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec) ;
266                             else if (wav_fmt->min.bytespersec == (wav_fmt->min.samplerate / wav_fmt->msadpcm.samplesperblock) * wav_fmt->min.blockalign)
267                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d (MS BUG!))\n", wav_fmt->min.bytespersec, bytespersec) ;
268                             else
269                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec, bytespersec) ;
270 
271                             if (wav_fmt->msadpcm.numcoeffs > ARRAY_LEN (wav_fmt->msadpcm.coeffs))
272                             {       psf_log_printf (psf, "  No. of Coeffs : %d (should be <= %d)\n", wav_fmt->msadpcm.numcoeffs, ARRAY_LEN (wav_fmt->msadpcm.coeffs)) ;
273                                     wav_fmt->msadpcm.numcoeffs = ARRAY_LEN (wav_fmt->msadpcm.coeffs) ;
274                                     }
275                             else
276                                     psf_log_printf (psf, "  No. of Coeffs : %d\n", wav_fmt->msadpcm.numcoeffs) ;
277 
278                             psf_log_printf (psf, "    Index   Coeffs1   Coeffs2\n") ;
279                             for (k = 0 ; k < wav_fmt->msadpcm.numcoeffs ; k++)
280                             {       char buffer [128] ;
281 
282                                     bytesread +=
283                                             psf_binheader_readf (psf, "22", &(wav_fmt->msadpcm.coeffs [k].coeff1), &(wav_fmt->msadpcm.coeffs [k].coeff2)) ;
284                                     snprintf (buffer, sizeof (buffer), "     %2d     %7d   %7d\n", k, wav_fmt->msadpcm.coeffs [k].coeff1, wav_fmt->msadpcm.coeffs [k].coeff2) ;
285                                     psf_log_printf (psf, buffer) ;
286                                     } ;
287                             break ;
288 
289             case WAVE_FORMAT_GSM610 :
290                             if (wav_fmt->gsm610.channels != 1 || wav_fmt->gsm610.blockalign != 65)
291                                     return SFE_WAV_GSM610_FORMAT ;
292 
293                             bytesread +=
294                             psf_binheader_readf (psf, "22", &(wav_fmt->gsm610.extrabytes), &(wav_fmt->gsm610.samplesperblock)) ;
295 
296                             if (wav_fmt->gsm610.samplesperblock != 320)
297                                     return SFE_WAV_GSM610_FORMAT ;
298 
299                             bytespersec = (wav_fmt->gsm610.samplerate * wav_fmt->gsm610.blockalign) / wav_fmt->gsm610.samplesperblock ;
300                             if (wav_fmt->gsm610.bytespersec != (unsigned) bytespersec)
301                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->gsm610.bytespersec, bytespersec) ;
302                             else
303                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->gsm610.bytespersec) ;
304 
305                             psf_log_printf (psf, "  Extra Bytes   : %d\n", wav_fmt->gsm610.extrabytes) ;
306                             psf_log_printf (psf, "  Samples/Block : %d\n", wav_fmt->gsm610.samplesperblock) ;
307                             break ;
308 
309             case WAVE_FORMAT_EXTENSIBLE :
310                             if (wav_fmt->ext.bytespersec != wav_fmt->ext.samplerate * wav_fmt->ext.blockalign)
311                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->ext.bytespersec, wav_fmt->ext.samplerate * wav_fmt->ext.blockalign) ;
312                             else
313                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->ext.bytespersec) ;
314 
315                             bytesread +=
316                             psf_binheader_readf (psf, "224", &(wav_fmt->ext.extrabytes), &(wav_fmt->ext.validbits),
317                                             &(wav_fmt->ext.channelmask)) ;
318 
319                             psf_log_printf (psf, "  Valid Bits    : %d\n", wav_fmt->ext.validbits) ;
320 
321                             if (wav_fmt->ext.channelmask == 0)
322                                     psf_log_printf (psf, "  Channel Mask  : 0x0 (should not be zero)\n") ;
323                             else
324                             {       char buffer [512] ;
325                                     unsigned bit ;
326 
327                                     wpriv->wavex_channelmask = wav_fmt->ext.channelmask ;
328 
329                                     /* It's probably wise to ignore the channel mask if it is all zero */
330                                     free (psf->channel_map) ;
331 
332                                     if ((psf->channel_map = calloc (psf->sf.channels, sizeof (psf->channel_map [0]))) == NULL)
333                                             return SFE_MALLOC_FAILED ;
334 
335                                     /* Terminate the buffer we're going to append_snprintf into. */
336                                     buffer [0] = 0 ;
337 
338                                     for (bit = k = 0 ; bit < ARRAY_LEN (channel_mask_bits) ; bit++)
339                                     {
340                                             if (wav_fmt->ext.channelmask & (1 << bit))
341                                             {       if (k > psf->sf.channels)
342                                                     {       psf_log_printf (psf, "*** More channel map bits than there are channels.\n") ;
343                                                             break ;
344                                                             } ;
345 
346                                                     psf->channel_map [k++] = channel_mask_bits [bit].id ;
347                                                     append_snprintf (buffer, sizeof (buffer), "%s, ", channel_mask_bits [bit].name) ;
348                                                     } ;
349                                             } ;
350 
351                                     /* Remove trailing ", ". */
352                                     bit = strlen (buffer) ;
353                     buffer [--bit] = 0 ;
354                                     buffer [--bit] = 0 ;
355 
356                                     if (k != psf->sf.channels)
357                                     {       psf_log_printf (psf, "  Channel Mask  : 0x%X\n", wav_fmt->ext.channelmask) ;
358                                             psf_log_printf (psf, "*** Less channel map bits than there are channels.\n") ;
359                                             }
360                                     else
361                                             psf_log_printf (psf, "  Channel Mask  : 0x%X (%s)\n", wav_fmt->ext.channelmask, buffer) ;
362                                     } ;
363 
364                             bytesread += psf_binheader_readf (psf, "422", &(wav_fmt->ext.esf.esf_field1), &(wav_fmt->ext.esf.esf_field2), &(wav_fmt->ext.esf.esf_field3)) ;
365 
366                             /* compare the esf_fields with each known GUID? and print? */
367                             psf_log_printf (psf, "  Subformat\n") ;
368                             psf_log_printf (psf, "    esf_field1 : 0x%X\n", wav_fmt->ext.esf.esf_field1) ;
369                             psf_log_printf (psf, "    esf_field2 : 0x%X\n", wav_fmt->ext.esf.esf_field2) ;
370                             psf_log_printf (psf, "    esf_field3 : 0x%X\n", wav_fmt->ext.esf.esf_field3) ;
371                             psf_log_printf (psf, "    esf_field4 : ") ;
372                             for (k = 0 ; k < 8 ; k++)
373                             {       bytesread += psf_binheader_readf (psf, "1", &(wav_fmt->ext.esf.esf_field4 [k])) ;
374                                     psf_log_printf (psf, "0x%X ", wav_fmt->ext.esf.esf_field4 [k] & 0xFF) ;
375                                     } ;
376                             psf_log_printf (psf, "\n") ;
377                             psf->bytewidth = BITWIDTH2BYTES (wav_fmt->ext.bitwidth) ;
378 
379                             /* Compare GUIDs for known ones. */
380                             if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_PCM))
381                             {       psf->sf.format = SF_FORMAT_WAVEX | u_bitwidth_to_subformat (psf->bytewidth * 8) ;
382                                     psf_log_printf (psf, "    format : pcm\n") ;
383                                     }
384                             else if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_MS_ADPCM))
385                             {       psf->sf.format = (SF_FORMAT_WAVEX | SF_FORMAT_MS_ADPCM) ;
386                                     psf_log_printf (psf, "    format : ms adpcm\n") ;
387                                     }
388                             else if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_IEEE_FLOAT))
389                             {       psf->sf.format = SF_FORMAT_WAVEX | ((psf->bytewidth == 8) ? SF_FORMAT_DOUBLE : SF_FORMAT_FLOAT) ;
390                                     psf_log_printf (psf, "    format : IEEE float\n") ;
391                                     }
392                             else if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_ALAW))
393                             {       psf->sf.format = (SF_FORMAT_WAVEX | SF_FORMAT_ALAW) ;
394                                     psf_log_printf (psf, "    format : A-law\n") ;
395                                     }
396                             else if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_MULAW))
397                             {       psf->sf.format = (SF_FORMAT_WAVEX | SF_FORMAT_ULAW) ;
398                                     psf_log_printf (psf, "    format : u-law\n") ;
399                                     }
400                             else if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM))
401                             {       psf->sf.format = SF_FORMAT_WAVEX | u_bitwidth_to_subformat (psf->bytewidth * 8) ;
402                                     psf_log_printf (psf, "    format : pcm (Ambisonic B)\n") ;
403                                     wpriv->wavex_ambisonic = SF_AMBISONIC_B_FORMAT ;
404                                     }
405                             else if (wavex_guid_equal (&wav_fmt->ext.esf, &MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT))
406                             {       psf->sf.format = SF_FORMAT_WAVEX | ((psf->bytewidth == 8) ? SF_FORMAT_DOUBLE : SF_FORMAT_FLOAT) ;
407                                     psf_log_printf (psf, "    format : IEEE float (Ambisonic B)\n") ;
408                                     wpriv->wavex_ambisonic = SF_AMBISONIC_B_FORMAT ;
409                                     }
410                             else
411                                     return SFE_UNIMPLEMENTED ;
412 
413                             break ;
414 
415             case WAVE_FORMAT_G721_ADPCM :
416                             psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->g72x.bytespersec) ;
417                             if (fmtsize >= 20)
418                             {       bytesread += psf_binheader_readf (psf, "22", &(wav_fmt->g72x.extrabytes), &(wav_fmt->g72x.auxblocksize)) ;
419                                     if (wav_fmt->g72x.extrabytes == 0)
420                                             psf_log_printf (psf, "  Extra Bytes   : %d (should be 2)\n", wav_fmt->g72x.extrabytes) ;
421                                     else
422                                             psf_log_printf (psf, "  Extra Bytes   : %d\n", wav_fmt->g72x.extrabytes) ;
423                                     psf_log_printf (psf, "  Aux Blk Size  : %d\n", wav_fmt->g72x.auxblocksize) ;
424                                     }
425                             else if (fmtsize == 18)
426                             {       bytesread += psf_binheader_readf (psf, "2", &(wav_fmt->g72x.extrabytes)) ;
427                                     psf_log_printf (psf, "  Extra Bytes   : %d%s\n", wav_fmt->g72x.extrabytes, wav_fmt->g72x.extrabytes != 0 ? " (should be 0)" : "") ;
428                                     }
429                             else
430                                     psf_log_printf (psf, "*** 'fmt ' chunk should be bigger than this!\n") ;
431                             break ;
432 
433             case WAVE_FORMAT_NMS_VBXADPCM :
434                             if (wav_fmt->min.channels != 1 || wav_fmt->min.bitwidth < 2 || wav_fmt->min.bitwidth * 20 + 2 != wav_fmt->min.blockalign)
435                                     return SFE_WAV_NMS_FORMAT ;
436 
437                             bytespersec = (wav_fmt->min.samplerate * wav_fmt->min.blockalign) / 160 ;
438                             if (wav_fmt->min.bytespersec == (unsigned) bytespersec)
439                                     psf_log_printf (psf, "  Bytes/sec     : %d\n", wav_fmt->min.bytespersec) ;
440                             else
441                                     psf_log_printf (psf, "  Bytes/sec     : %d (should be %d)\n", wav_fmt->min.bytespersec, bytespersec) ;
442                             if (fmtsize >= 18)
443                             {       bytesread += psf_binheader_readf (psf, "2", &(wav_fmt->size20.extrabytes)) ;
444                                     psf_log_printf (psf, "  Extra Bytes   : %d\n", wav_fmt->size20.extrabytes) ;
445                                     } ;
446                             break ;
447 
448             default :
449                             psf_log_printf (psf, "*** No 'fmt ' chunk dumper for this format!\n") ;
450                             return SFE_WAV_BAD_FMT ;
451             } ;
452 
453     if (bytesread > fmtsize)
454     {       psf_log_printf (psf, "*** wavlike_read_fmt_chunk (bytesread > fmtsize)\n") ;
455             return SFE_WAV_BAD_FMT ;
456             }
457     else
458             psf_binheader_readf (psf, "j", fmtsize - bytesread) ;
459 
460     psf->blockwidth = wav_fmt->min.channels * psf->bytewidth ;
461 
462     return 0 ;
463 } /* wavlike_read_fmt_chunk */